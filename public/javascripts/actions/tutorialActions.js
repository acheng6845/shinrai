import React from 'react';

export function fetchTutorialPage(index) {
	const dataArray = [
		{chapter: "Execution Context", sections: [
			{heading: "Lexical Scope", body: "When the source code is run through a compiler, the scope gets defined in the lexing phase, according to where names and variables were authored in the source code - hence the name, lexical scope."},
			{heading: "Closures", body: (
				<div>
					A function that can remember and access its lexical scope even when that function is executing outside said lexical scope is considered to be a closure.
					<br/>For example:<br/>Function b = (arg1) => {"{"}<br/>&nbsp;&nbsp;var a;<br/>&nbsp;&nbsp;return function(arg2) console.log(a);<br/> {"}"}<br/>var c = b();<br/>c(); //returns a, despite variable a being outside of the lexical scope of function b.
				</div>
			)}	
		]},
		{chapter: "Hoisting", sections: [
			{heading: "Variable Declarations", body: "The JavaScript compiler has been constructed such that variables in the script are hoisted, without content or expressions, above the rest of the script. In other words, it's similar to writing a dictionary with the words first before the definitions. However, variables declared with let are not hoisted."},
			{heading: "Function Declaration", body: "On the other hand, function declarations - function example() {} - are also hoisted to the top of the script, but their contents/definitions go along with them. \nFurthermore, function declarations are hoisted ahead of variable declarations and can be overridden, i.e., duplicates after the first are ignored."},
			{heading: "Function Expression", body: "But, function declarations - var func = () => {} - are called in-line."},
			{heading: "When to Use Either?", body: "Generally, function expressions allow for less surprises and more flexibility, yet they come at the price of being anonymous functions for debuggers. \nA workaround for this on newer browsers would be to use: var foo = function bar() {return 'foobar'};"},
			{heading: "Function Scoping", body: "The lexical scope of a function is the content within its brackets, i.e., function foo() {scope}."},
			{heading: "Block Scoping", body: "Not to be confused, the scope within if, while, and for statements are considered block scopes. These statements share their scope with the global scope unless the variables were instantiated with const or let."}
		]},
		{chapter: "Binding", sections: [
			{heading: "Call", body: "Ex.: Arrays.prototype.slice.call(object, ...parameter)."},
			{heading: "Apply", body: "Ex.: Arrays.prototype.slice.apply(object, [parameters])."},
			{heading:"Bind", body: "Ex.: var x = multipleArgFunction.bind(null, x, y, z)."},
			{heading: "Lexical This", body: "Lexical this essentially refers to the scope of the object."}
		]},
		{chapter: "Objects", sections: [
			{heading: "Prototypes", body: "Object prototypes are essentially defined to be from where JavaScript Objects inherit their properties and methods.\nTo add properties to an object, it's simply object.property = x; however, for prototypes, the property must be added to the constructor function or through Object.prototype.property = x."},
			{heading: "Constructors", body: "Ex.: function Foo(a,b,c) {\nthis.aProperty = a;\nthis.bProperty = b;\nthis.cProperty = c;\n}\nThis would be the basic constructor for a Foo object prototype. Take note that the name starts with a capital letter."},
			{heading: "Mixins", body: "Then, there is the middleground between delegations (call, apply) and inheritance called mixins. These allow for entire functional units to be borrowed and accessed with minimal syntax. Generally, these are classes that define a set of functions relating to a type, usually considered abstract, for their functions to then be borrowed by more concrete classes."},
			{heading: "Mixins - Archaic Logic", body: "An old methodology for constructing mixins utilizes extend functions to copy mixin functions into receiving objects. \nFunction extend(destination, source) {\n for(var element in source) {\n if(source.hasOwnProperty(element)) {\n destination[element] = source[element];\n}}}\nextend(Obj.prototype, mixinObj);"},
			{heading: "Mixins - Functional Logic", body: "var asCircle = function() { this.area = () => {return Math.PI * this.radius * this.radius}; return this; var circle = function(radius) { this.radius = radius; }; asCircle.call(Circle.prototype); var circle1 = new Circle(5); circle1.area();" },
			{heading: "Mixins - Functional with Options", body: "var asOval = (options) => { this.grow = () => { this.shortRadius += options.growBy; }; this.shrinks = () => { this.shortRadius -= options.shrinkBy;}; return this; }; var Oval = (shortRadius) => {this.shortRadius = shortRadius;}; asOval.call(Oval.prototype, {growBy: 2, shrinkBy: 2}); "},
			{heading: "Mixins - Functional with Caching and Closure", body: "var asRectangle = (function(){ function area() {return this.length * this.width;} return function() {this.area = area; return this;} })(); var Rectangle = (length, width) => {this.length = length; this.width = width;}; asRectangle.call(Rectangle.prototype);"},
			{heading: "Mixins - Functional and Options with Currying", body: "function.prototype.curry = () => { var fn = this; var args = [].slice.call(arguments, 0); return () => { return fn.apply(this, args.concat([].slice.call(arguments, 0))); }} var asRectangle = (function() { function grow(growBy) { this.length += growBy, this.width += growBy; } return (options) => { this.grow = grow.curry(options['growBy']); return this; }})(); asRectangle.call(Rectangle.prototype, {growBy: 2}); "}
		]},
		{chapter: "Function Composition", sections: [
			{heading: "Introduction", body: "In math, function compositions are defined as f o g or f(g(x)). Similarly, function compositions in JavaScript can be expressed through cascading functions, but in reverse. For example, foo(bar(x)) would be written as bar(x).foo(y -> y)."},
			{heading: "Currying", body: "A cleaner implementation of function compositions would be through a technique called currying. This is where functions with multiple arguments, through the use of closures, can be inputted each argument separately, or reduced, before finally executing. For example: add = (a, b) => return a + b; curriedAdd = (a) => { return (b) => add(a, b); }."},
			{heading: "Uncurrying", body: "In order to uncurry or to retrieve the multiple argument function, simply input all of the arguments into the curry function. Ex.: curriedAdd = (a) => (b) => return a + b; add = (a,b) => curriedAdd(a)(b);"},
			{heading: "How is Curry Used?", body: "JavaScript's Function prototype's bind method implements currying, i.e., multiply = multiply.bind(null, 3); multiply(2) // returns 6. Furthermore, the React-Redux connect method utilizes currying to map the states to the props in a component. Lastly, event handlers are another application of currying." },
			{heading: "Pipe", body: "Another implementation of function compositions can be through pipes, which would be similar in application to function chaining."},
			{heading: "Higher Order Functions", body: "Higher Order Functions are functions that can take another function as an argument or return a function. As such, currying can be used to generate higher order functions."}
		]},
		{chapter: "Event Handling", sections: [
			{heading: "Event Delegation", body: "Since events bubble upward from children nodes to parents, it's possible to use parent components to delegate event responses according to the triggered node's properties."},
			{heading: "Event Delegation Example", body: "document.getElementById('list').addEventListener('click', (e) => { if(e.target && e.target.nodeName == 'li') alert('list item', e.target.id.replace('post', ''), 'was clicked!')});"},
			{heading: "Event Bubbling", body: "Event bubbling can also be stopped by including this method in the event handler: (e) => {event.stopPropagation()}; "}
		]},
		{chapter: "Type Coercion", sections: [
			{heading: "Data Types", body: "The different data types in JavaScript are: string, number, boolean, object, function, null, and undefined."},
			{heading: "Objects", body: "Then, the objects in JavaScript are Object, Date, and Array."},
			{heading: "typeof", body: "The typeof method would return the data type of a variable; however, the exceptions are that NaN returns number, array.date.null returns an object, and undefined returns undefined."},
			{heading: "instanceof", body: "This method returns a boolean value denoting whether a variable is an instance of the designated Object. Comparisons are done by comparing Object.getPrototypeOf(o) to Object.prototype."},
			{heading: "toString", body: "Another method for determining type coercion is through Object.prototype.toString.call(o) which returns a string, [object ObjectName]. The reason that toString cannot be called directly onto an object o is that Strings, Numbers, Arrays, and Date override the Object's toString method."}	
		]},
		{chapter: "Handling Asynchronous Calls", sections: [
			{heading: "Callbacks", body: "var a = (args, callbackFunction) => {} "},
			{heading: "Promises", body: "new Promise((resolveFunction, rejectFunction)) => {}); Promise.then(onFulfilled?: Function, onRejected?: Function) => Promise"},
			{heading: "Promise Chaining", body: "fetch(url).then(process).then(save).catch(handleErrors);"},
			{heading: "Async/Await", body: "An alternative to the prevalent promises and callbacks in writing asynchronous code are async/await which is a layer built on top of promises. While async/await are non-blocking like promises, they help to transform asynchronous code into cleaner synchronous-like code. Example code: const exampleAction = async () => { console.log(await getJSON()); return true; }"},
			{heading: "Async/Await Explanation", body: "A function denoted by the async keyword inherently becomes a promise where the resolve value is the function's return value. Meanwhile, await can only be called within an async function where the promise (getJSON in this case) will be waited to resolve before being printed to the console."}
		]},
		{chapter: "Selecting or Finding Nodes", sections: [
			{heading: "CSS Selectors", body: "Non-Live Results: document.querySelector(CSS selectors)/DFS, document.querySelectorAll(CSS Selectors), element.matches(CSS Selectors) === true, element.querySelector(CSS Selectors). Live Results: document.getElementByTagName, document.getElementById"},
			{heading: "CSS Selectors List", body: (<div>.example = elements with class='example'<br/>#name = elements with id='name'<br />* = all elements<br/>p = paragraph elements<br/>p, div = paragraph and div elements<br/>div p = paragraph elements within div elements<br/>div > p = paragraph elements with parents are div elements<br/>div + p = paragraph elements placed immediately after div elements<br/>p ~ ul = ul elements preceded by a paragraph element<br/>[attr] = elements with attr attribute<br/>[attr=x] = elements with attr attribute equal to x<br/>[attr~=x] = elements with attr attribute containing the word 'x'<br/>[attr|=x] = elements with an attr attribute value starting with 'x'<br/>a[href^='x'] = a elements with href attribute value beginning with 'x'<br/>a[href$='x'] = a elements with href attribute value ending with 'x'<br/>a[href*='x'] = a elements with href attribute value containing substring 'x'<br/>a:active/hover/link/visited = active/hovered/unvisited/visited link<br/>p::after/before = insert something after/before each paragraph element<br/>input:checked/disabled/enabled/focus/optional/read-only/read-write/required = every checked/disabled/enabled/focused/optional/read-only/read-write/required input element<br/>input:in-range/out-of-range/invalid/valid = every input element where the value is in-range/out-of-range/invalid/valid<br/>x:empty = every x element with no children<br/>p:first-child/last-child/nth-child(n)/nth-last-child(n) = every paragraph element which is its parent's first/last/nth/nth-from-last child<br/>p::first-letter/line = selects the first letter/line of every paragraph element<br/>p:first-of-type/last-of-type/nth-of-type(n)/nth-last-of-type(n) = every paragraph element that is the first/last/nth/nth-from-last paragraph element child of its parent<br/>p:only-of-type/only-child = every paragraph element that is the only paragraph element/child of its parent<br/>p:lang(language) = every paragraph element with a lang attribute equal to the language<br/>:not(selector) = every element that does not match the selector<br/>:root = document's root element<br/>::selection = portion of element selected by a user<br/>#id:target = current active #id element</div>)}
		]},
		{chapter: "DOM Traversal and Manipulation", sections: [
			{heading: "Traversal Up and Down", body: (<div>node.parentNode - returns parent Node<br/>node.firstChild - returns first child<br/>node.lastChild - returns last child<br/>node.childNodes - returns array of children nodes</div>)},
			{heading: "Traversal Left and Right", body: (<div>node.previousSibling - returns previous sibling node<br/>node.nextSibling - returns next sibling node</div>)},
			{heading: "Manipulation", body: (<div>Adding Nodes: element.append(node), element.prepend(node), element.appendTo("targetElement"), element.prependTo("targetElement"), element.before(CSS Selectors), element.after(CSS Selectors), element.insertBefore(CSS Selectors), element.insertAfter(CSS Selectors)<br/>Removing Nodes: $(CSS Selectors).remove(), $(CSS Selectors).detach() - keeps data/events, $(CSS Selectors).empty() - removes children and content<br/>Replacing Nodes: $(CSS Selectors).replaceWith(node), $(node).replaceAll(CSS Selectors)<br/>Copying Nodes: $(CSS Selectors).clone(true/false) - returns cloned elements with/without event handlers copied<br/>Creating Nodes: document.createElement("element"), document.createTextNode(String)<br/>Changing Text Content: $(CSS Selectors).html(HTML/Text node), $(CSS Selectors).text(Text node)<br/>Toggling: $(CSS Selectors).toggleClass(className)<br/>Removing or Adding Class Names: $(CSS Selectors).removeClass(className), $(CSS Selectors).addClass(className)</div>)}
		]},
		{chapter: "Performance", sections: [
			{heading: "Document Fragments", body: (<div>Document Fragments are a way to manipulate the DOM without interacting with the live/visible DOM until the end.<br/>Example:<br/>const fragment = document.createDocumentFragment();<br/>var listItem = document.createElement("li");<br/>fragment.appendChild(listItem);<br/>document.querySelector("ul").appendChild(fragment);</div>)},
			{heading: "Node Caching", body: (<div>Another technique to increase DOM Manipulation perforamnce is to cache the results of a query.<br/>Example:<br/>const $id = document.getElementById('id');<br/>$id.append(node);</div>)}
		]},/*
		{chapter: "CSS", sections: [
			{heading: "Layout", body: ""},
			{heading: "Responsive Design", body: ""},
			{heading: "Adaptive Design", body: ""},
			{heading: "Specificity", body: ""},
			{heading: "Namespacing and Naming of ClassNames", body: ""}
		]},
		{chapter: "HTML", sections: [
			{heading: "", body: ""}
		]},*/
		{chapter: "System Design", sections: [
			{heading: "Rendering", body: (<div>Client Side (CSR): The advantages of client side rendering are that it's excellent for rendering web applications, there are plenty of powerful JavaScript libraries and frameworks to choose from, rendering is extremely fast since the duplicate content doesn't have to be reloaded, and it is possible to create rich user interactions. Its downfalls come with extra implementation complexities to attain good Search Engine Optimizations, the requirement of external libraries, and a possibly long initial load time.<br/>Server Side (SSR): On the other hand, server side rendering allows for better SEO and quick initial load times, which is great for static sites. However, that also means that the server must receive multiple requests and deliver responses for each page, thus, pages will need to be re-rendered fully, creating a slowed process. Furthermore, without a JavaScript library, it's difficult to create fulfilling user interactions.<br/>Universal Rendering: With React, universal rendering is where the server renders the react components and sends the result as HTML to the browser with the initial load. Then, the client takes over and re-renders the component as well as further rendering needs. This is only possible when the server understands JSX elements through modules like Babel (with or without webpack). Doing so allows for the web application to have good SEO while also fast and powerful rendering; however, universal rendering also introduces extra complexities and extra maintanence requirements that may not justify the improvements universal rendering brings.</div>)},
			//{heading: "Layout", body: ""},
			{heading: "State Management", body: (<div>Unidirectional: This type of data binding requires that HTML values can only be changed through JavaScript or the controller. There is only one watcher checking the controller and the HTML simply sends events back to that controller. An example of which is React and how only its components can change the state. This data flow leads to more predictable and bug-free code.<br/>Two-Way Data Binding: However, it is also possible for both the controller and the HTML to alter the state in a two-way binding. In such a case, there are two watchers, one for each actor and they serve to detect and communicate any alterations between the controller and view. At the cost of extra complexities and possible bugs, two-way binding allows for users to immediately update both model and view values through the UI. An example of a framework that utilizes two-way data binding is Angular.<br/>Passive Programming Model: When one module is responsible for altering the state of another module, it is called a proactive object while the acted upon module is a passive object. This concept of state management is known as passive programming.<br/>Reactive Programming Model: Meanwhile, if an object changes its own state by listening to events emitted by other objects, the object is called reactive and the event emitters are called listenables. This relationship is known as reactive programming.<br/>Essentially, reactive programming is manipulating, merging, filtering, and mapping asynchronous data streams. Then, what is a stream that is so central to reactive programming? It's a sequence of ongoing events sorted by time. Three outputs can be produced through streams - value, error, and a completion signal. Everythng then can be detailed by the Observer Design Pattern where functions called observers deal with these outputs by subscribing or listening to these data streams.<br/>Then, how does one use streams? One example is through clicks on a button. These clicks can be aggregated into lists according to intervals where the button isn't clicked. This stream can then be mapped according to length values and finally filtered to only contain certain amounts of clicks in successive order.</div>)},
			{heading: "Asynchronous Flow", body: (<div>XHR vs. Bidirectional flow<br/>Older browsers: XHR vs. Script Tags vs. Hidden iFrames</div>)},
			{heading: "Separation of Concerns", body: (<div>MVC: Model-View-Controller -> the Model emits events that alter the View which passes commands to the Controller that can manipulate the Model.<br/>MVVM: Model-View-Viewmodel or View-Model -> the View Model retrieves data from the Model and reformats or serves the data raw to the View. The View Model also contains functions that correspond to events or commands triggered from the View as well as managing logical state changes that alter the values in the View. Thus, the View Model is two-way binded to the View.<br/>MVP: Model-View-Presenter -> the Presenter can update the View and accepts events from the Model while also having the ability to manipulate it. With a passive View, the View is unaware of the Model and only receives updates from the Presenter which handles changes in the Model. Meanwhile, with a Supervising Controller, the View directly accesses the Model while the Presenter updates the Model and sometimes alters the View when additional logic is needed.</div>)},
			{heading: "Multi-Device Support", body: "Responsive Layout that adapts to different screen sizes. Do not have hidden contents for certain devices. Make certain that the website is readable on all devices. Overall experience should be consistent across all devices. And, optimal website perforamne across all devices must be the top priority."},
			{heading: "Asset Delivery", body: "Build Dependencies -> Testing (Unit and Integration) -> Deployment"}

		]},
		{chapter: "Event Loop", sections: [
			{heading: "Call Stack", body: "A call stack is a data structure which records the context where the code is running. Once the program enters a function, the context is pushed into the stack and once the function returns something, the stack is popped. Since JavaScript is single-threaded, there is only one asynchronous call stack."},
			{heading: "Blocking", body: "Generally, blocking is defined by code that is slow and on a call stack, such as image processing and network requests."},
			{heading: "Asynchronous Callbacks", body: "In handling blocking in the call stack, asynchronous callbacks are utilized. These callbacks queue the functions to be pushed into the call stack at a later time, i.e., setTimeOut(), AJAX requests, eventHandlers."},
			{heading: "Concurrency", body: "While the JavaScript runtime is asynchronous and can only maintain one call stack, the browser has APIs, acting as additional threads, which can be utilized to run concurrently with the runtime. Thus, when setTimeOut is called into the call stack, it triggers the respective web API which countdowns the millisecond parameter provided and pops the stack. Then, once the web API is done, it pushes the callback onto the callback queue."},
			{heading: "Event Loop", body: "The job of the event loop is then to watch the call stack and callback queue. When the stack is empty and the queue isn't empty, it polls the first item from the queue and pushes it onto the stack."},
			{heading: "Rendering", body: "The browser looks to render the page 60 fps, however, it cannot render when the call stack isn't empty. In other words, every 16 ms, the browser pushes a render into the render queue, which has higher priority than the callback queue for the event loop. Thus, when functions are queued up asynchronously, it gives time for the browser to pop the render queue in between the code processing rather than if it was done synchronously."}
		]}
	];
	return {
		type: "SELECT_INDEX",
		payload: {
			data: dataArray[index],
			chapters: dataArray.map((data) => data.chapter),
			index: index,
		}
	}
}